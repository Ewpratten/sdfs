<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Software Development From Scratch</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="2_prerequisites.html"><strong aria-hidden="true">2.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="3_memory.html"><strong aria-hidden="true">3.</strong> Computer Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1_hex_and_binary.html"><strong aria-hidden="true">3.1.</strong> Hex and Binary</a></li></ol></li><li class="chapter-item expanded "><a href="4_machine_code.html"><strong aria-hidden="true">4.</strong> Machine Code</a></li><li class="chapter-item expanded "><a href="5_assembly.html"><strong aria-hidden="true">5.</strong> Assembly: Machine Code for Humans</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1_registers.html"><strong aria-hidden="true">5.1.</strong> Registers: A Special Type of Memory</a></li><li class="chapter-item expanded "><a href="5.2_adder.html"><strong aria-hidden="true">5.2.</strong> Using a Register: Creating an Adder</a></li><li class="chapter-item expanded "><a href="5.3_averaging.html"><strong aria-hidden="true">5.3.</strong> More Math: Averaging Two Numbers</a></li></ol></li><li class="chapter-item expanded "><a href="6_stack_and_heap.html"><strong aria-hidden="true">6.</strong> The Stack and Heap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.1_brief_intro_to_functions.html"><strong aria-hidden="true">6.1.</strong> Brief Introduction to Functions</a></li><li class="chapter-item expanded "><a href="6.2_calling_conventions.html"><strong aria-hidden="true">6.2.</strong> Calling Conventions</a></li><li class="chapter-item expanded "><a href="6.3_averaging_with_functions.html"><strong aria-hidden="true">6.3.</strong> Averaging Two Numbers: Now with Functions!</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Software Development From Scratch</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/ewpratten/sdfs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Hi, I'm <a href="https://github.com/Ewpratten">Evan Pratten</a>, and I felt like writing another &quot;book&quot; about programming. Last time I did this, I was still very new to just about everything I cover in this one, and got a lot of things wrong.</p>
<p>The main goal of my second book is to build a &quot;from the ground up&quot; guide on programming that I can point my friends at instead of my usual <em>getting horribly sidetracked</em> when explaining low-level concepts.</p>
<p>If you find this material useful, please reach out to me and let me know!</p>
<p>I cannot guarantee that everything in this book will be 100% accurate, but I intend to keep it as close to the truth as possible. If you would like to make a revision or suggestion, open an <a href="https://github.com/Ewpratten/sdfs/issues">Issue</a> or <a href="https://github.com/Ewpratten/sdfs/pulls">Pull Request</a>.</p>
<p>Almost every programming tutorial I have ever seen jumps straight in to the high-level code, and leaves out any detail on whats actually going on when you run your programs. The goal of this book is to instead teach you the very basics of how a computer works, then build on top of that. Don't let that scare you though, I try to keep all the &quot;boring&quot; details as interesting as possible, and provide many examples and links to help you understand what you are reading.</p>
<hr />
<p><img src="https://i.redd.it/v049x9mn32w41.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>This book makes some assumptions about your computer. If your setup does not match the following, you may need to adjust the examples.</p>
<p>For the sake of simplicity, and because this is where I am the most knowledgeable, I will assume you are using a computer built on the <code>x86_64</code> architecture (Intel or AMD processor), and running a <a href="https://www.debian.org/">Debian</a>-based operating system (I am using <a href="https://ubuntu.com/">Ubuntu</a> personally).</p>
<p>If your computer is running on a different architecture, say ARM for example, the assembly examples will simply not work for you.</p>
<p>As for Windows users, feel free to install <a href="https://wiki.ubuntu.com/WSL">Ubuntu WSL</a> and follow along from inside your WSL terminal.</p>
<p>I also make the assumption that you are comfortable with some basic computer-related terms (CPU, RAM, etc), and know how to use your computer's command line.</p>
<h2 id="installing-the-needed-software"><a class="header" href="#installing-the-needed-software">Installing the needed software</a></h2>
<p>To follow along, you will need to install a few things on your computer. In order to provide multiple examples, I use a few different languages in this book. The things marked with a <strong>bold</strong> star below are the important ones to install, the others are only necessary if you intend to follow <em>every single</em> example.</p>
<ul>
<li><strong>*<a href="https://linuxize.com/post/how-to-install-gcc-compiler-on-ubuntu-18-04/#installing-gcc-on-ubuntu"><code>build-essential</code></a></strong> (Just follow the <em>&quot;Installing GCC on Ubuntu&quot;</em> section)</li>
<li><strong>*<a href="https://www.rust-lang.org/tools/install"><code>rust</code></a></strong></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-python-3-and-set-up-a-programming-environment-on-an-ubuntu-20-04-server"><code>python3</code></a> (Just follow <em>&quot;Step 1&quot;</em>)</li>
<li><a href="https://www.baeldung.com/java-sdkman-intro"><code>14.0.1.j9-adpt</code></a> (Just follow Steps 1 to 5.3)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-memory"><a class="header" href="#computer-memory">Computer Memory</a></h1>
<p>Arguable the most important concept when writing any computer program is <em>memory</em>. At this point in the book, I'll leave memory as more of an abstract <em>thing</em> than explaining how its physically working, and how it is broken up.</p>
<p>Your computer can remember things, but there is also a general tradeoff between how quickly  it can pull up such data, and how long the data can exist. This is why you have seperate RAM and Hard Drive in your computer, since the RAM is fast but loses information when powered down, but the Hard Drive is the opposite.</p>
<p>The easiest way to think of your computer's memory is as one <em>really long</em> list of small things. Each &quot;small thing&quot; being a <a href="https://en.wikipedia.org/wiki/Byte">Byte</a>.</p>
<h2 id="addressing-memory"><a class="header" href="#addressing-memory">Addressing Memory</a></h2>
<p>Since computers have so much memory, it is very important to have a way to specifiy which location (or &quot;slot&quot;, or &quot;item in the list&quot;) you want to access. Luckily, we can just do this by specifying which <em>element</em> we want. Every memory location is numbered, the first being at position <code>0</code>.</p>
<p>Since computers have <em>so much</em> memory, these numbers get big <em>fast</em>. The solution in the computing world is to use a different numbering system, called <em>base-16</em> or <a href="https://en.wikipedia.org/wiki/Hexadecimal"><em>hexadecimal</em></a>. The first memory location is still <code>0x00</code> (notice, its written a little differently), but what would have been location <code>10</code> is now written as <code>0x0A</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sidenote-hexidecimals-relation-to-binary"><a class="header" href="#sidenote-hexidecimals-relation-to-binary">Sidenote: Hexidecimal's Relation to Binary</a></h1>
<p>I'm sure you've heard of <a href="https://en.wikipedia.org/wiki/Binary_code"><em>binary</em></a> before, it is the lowest-level numbering system used in computing, useful for showing the electrical state of things (for example, each physical bit that makes up the byte in a memory location).</p>
<p>Let's take the decimal number <code>237</code>, and represent it as 8 bits in binary:</p>
<pre><code>11101101
</code></pre>
<p>There is no way any of us are going to remember this sequence of <code>1</code> and <code>0</code>. What we can do however is split it in half:</p>
<pre><code>1110 1101
</code></pre>
<p>With these halves (called <a href="https://en.wikipedia.org/wiki/Nibble">nibbles</a>), we then can convert each nibble to a single hexidecimal digit:</p>
<pre><code>E D
</code></pre>
<p>Joining them gives us the hexidecimal number <code>0xED</code>. While this feels more like a waste of time than anything, it is occasionaly useful for converting numbers the other way. You can encounter the number <code>0xF0</code>, and know easily that the first nibble will be all <code>1</code>s, and the second nibble will be all <code>0</code>s.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="machine-code"><a class="header" href="#machine-code">Machine Code</a></h1>
<p>When a computer is powered on, it loads some information into memory, then passes the first byte from memory into the CPU. Each of these bytes has a special meaning to the CPU, telling it what to do next. We call these <em>Instructions</em>, because they instruct the CPU what to do.</p>
<p><em>Quick sidenote: The CPU doesn't actually read the <strong>first</strong> byte. The byte number depends on the specific CPU, but that doesn't matter for this section.</em></p>
<p>While I am about to introduce you to programming your computer by writing the bytes to memory manually, you will never do or see this again.</p>
<h2 id="your-first-program-jump-loop"><a class="header" href="#your-first-program-jump-loop">Your First Program: Jump Loop</a></h2>
<p>One of the simplest programs I can think of is one that never ends. We will:</p>
<ol>
<li>Have the CPU read the first byte in memory
<ul>
<li>This byte contains an instruction telling the CPU to read the third byte in memory</li>
</ul>
</li>
<li>At the third byte, we will put an instruction telling the CPU to go back to the first byte</li>
</ol>
<p>This will cause an infinite loop of <em>jumping</em> back anf fourth between the first and third bytes.</p>
<p>Since we are working with the <code>x86_64</code> architecture, we will use what is called <em>X86 Machine Code</em> to write this program. Each architecture has a different mapping between which bytes do what when passed to the CPU.</p>
<p>The following instruction is all we need for this program</p>
<table><thead><tr><th>Instruction</th><th>Description</th></tr></thead><tbody>
<tr><td><code>0xEB</code></td><td>SHORT Jump</td></tr>
</tbody></table>
<p>A <em>SHORT Jump</em> is what we call it when the CPU needs to move to another instruction that is nearby in memory (within a couple hundred locations, not thousands).</p>
<p>Using just this instruction, we can write out first program right now (although actually running it is impractical, so we won't do that). The bytes in memory, in order are:</p>
<pre><code>0xEB
0x00
0xEB
0xFC
</code></pre>
<p>As you can see, even though we are only doing two instructions, there are four bytes. This is because the extra bytes (<code>0x00</code> and <code>0xFC</code>) are used to tell the CPU <em>where</em> to jump to. A much more in-depth explication on what those bytes are doing can be found <a href="https://thestarman.pcministry.com/asm/2bytejumps.htm">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assembly-machine-code-for-humans"><a class="header" href="#assembly-machine-code-for-humans">Assembly: Machine Code for Humans</a></h1>
<p>As I mentioned about binary notation in <a href="/3.1_hex_and_binary.html"><em>Hexidecimal's Relation to Binary</em></a>, the same applies to machine code. There is no way we are going to remember every byte and what it does (although reference books do exist on this, and Intel's is notoriously <em>huge</em>).</p>
<p>This is where we step in to the world of human-readable programming languages. At some point in the past, people decided that we needed a better way to program computers, and came up with a little thing called <a href="https://en.wikipedia.org/wiki/X86_assembly_language"><em>Assembly</em></a>. Assembly code is still almost exactly the same as machine code, except it uses human-friendly <a href="https://en.wikipedia.org/wiki/Mnemonic"><em>mnemonics</em></a> instead of the machine-oriented <em>opcodes</em> we saw before.</p>
<p>These mnemonics would give out <em>SHORT Jump</em> instruction (<code>0xEB</code>) a nicer name: <code>jmp</code>.</p>
<p>We also gain the ability to <em>label</em> things, so instead of remembering which of those extra bytes jumps where, we let the computer figure that out for us.</p>
<p>Our program from the previous section, rewritten in Intel Assembly now looks like this:</p>
<pre><code class="language-x86asm">loop:
    jmp main
main:
    jmp loop
</code></pre>
<p><code>loop</code> and <code>main</code> are labels, and the <code>jmp</code> instructions should be pretty self-explanatory at this point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registers-a-special-type-of-memory"><a class="header" href="#registers-a-special-type-of-memory">Registers: A Special Type of Memory</a></h1>
<p>Back in the <a href="/3_memory.html"><em>Computer Memory</em></a> page, I said I wasn't going to explain how memory is broken up. This page is the first of a few where I'll explain it anyways.</p>
<p><code>x86_64</code> cpus have a very small handful of very special memory locations called registers. These are physically <em>inside</em> the CPU, making them extremely fast to interact with. Due to this, they are being used all the time, and pretty important to understand.</p>
<p>Each architecture handles this a little different, but <code>x86_64</code>'s registers can hold <code>64</code> bits of data <em>per register</em> (That's where the <code>_64</code> comes from, regular <code>x86</code> only holds <code>32</code> bits).</p>
<p>In assembly code, we can directly access these registers using their special names.</p>
<table><thead><tr><th>Register</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RAX</code></td><td>General purpose</td></tr>
<tr><td><code>RBX</code></td><td>General purpose</td></tr>
<tr><td><code>RCX</code></td><td>General purpose</td></tr>
<tr><td><code>RDX</code></td><td>General purpose</td></tr>
<tr><td><code>RSP</code></td><td><a href="/6_stack_and_heap.html">Stack</a> pointer</td></tr>
<tr><td><code>RBP</code></td><td>Stack base pointer</td></tr>
<tr><td><code>RSI</code></td><td>General purpose</td></tr>
<tr><td><code>RDI</code></td><td>General purpose</td></tr>
<tr><td><code>R8</code> to <code>R15</code></td><td>General purpose</td></tr>
</tbody></table>
<p>As I mentioned earlier, these registers are <code>64</code> bits long, <em>way</em> bigger than we need most of the time. To make things easier for smaller values, Intel assembly lets us specify that we only want to access <em>part</em> of a register, meaning we could store up to three <em>separate</em> values in the same register, while treating it as three separate virtual registers.</p>
<p>We can use the following tables to determine which mnemonic to use for each virtual register:</p>
<table><thead><tr><th>Base Register</th><th>32-bit segment</th><th>16-bit segment</th><th>8-bit segment</th></tr></thead><tbody>
<tr><td><code>RAX</code></td><td><code>EAX</code></td><td><code>AX</code></td><td><code>AL</code></td></tr>
<tr><td><code>RBX</code></td><td><code>EBX</code></td><td><code>BX</code></td><td><code>BL</code></td></tr>
<tr><td><code>RCX</code></td><td><code>ECX</code></td><td><code>CX</code></td><td><code>CL</code></td></tr>
<tr><td><code>RDX</code></td><td><code>EDX</code></td><td><code>DX</code></td><td><code>DL</code></td></tr>
<tr><td><code>RSP</code></td><td><code>ESP</code></td><td><code>SP</code></td><td><code>SPL</code></td></tr>
<tr><td><code>RBP</code></td><td><code>EBP</code></td><td><code>BP</code></td><td><code>BPL</code></td></tr>
<tr><td><code>RSI</code></td><td><code>ESI</code></td><td><code>SI</code></td><td><code>SIL</code></td></tr>
<tr><td><code>RDI</code></td><td><code>EDI</code></td><td><code>DI</code></td><td><code>DIL</code></td></tr>
<tr><td><code>R8</code> to <code>R15</code></td><td><code>R8D</code> to <code>R15D</code></td><td><code>R8W</code> to <code>R15W</code></td><td><code>R8B</code> to <code>R15B</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-a-register-creating-an-adder"><a class="header" href="#using-a-register-creating-an-adder">Using a Register: Creating an Adder</a></h1>
<p>Real quickly, to show how you might use a register in your code, we'll create our second program.</p>
<p>This program will store the number <code>1</code> in the register <code>RAX</code>, then add <code>3</code> to it, and store that result in <code>RAX</code> again.</p>
<pre><code class="language-x86asm">main:
    movl $1, %rax
    addl $3, %rax
</code></pre>
<p>This is the last time I'll show the generated machine code for some assembly. This program will produce the following machine code when compiled:</p>
<pre><code>48 8b 04 25 01 00 00 00 48 03 04 25 03 00 00 00
</code></pre>
<p>As you can see, this is starting to get very unreasonable to understand. Good thing we switched to assembly, isn't it? 😉</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-math-averaging-two-numbers"><a class="header" href="#more-math-averaging-two-numbers">More Math: Averaging Two Numbers</a></h1>
<p>Using our new-found ability to store things in registers, and perform operations on them, let's write a program that finds the average between the following sets of numbers:</p>
<ul>
<li><code>1</code> and <code>7</code></li>
<li><code>2</code> and <code>10</code></li>
<li><code>5</code> and <code>31</code></li>
</ul>
<p>As you should already know, to find the average between numbers \(A\) and \(B\), we compute:</p>
<p>\[
\frac{A + B}{2}
\]</p>
<p>Since we are going to perform the same action multiple times, I'll write the logic once in a snippet below, then we can re-use it in the main program. The snippet below will take \(A\) and \(B\) as the values in registers <code>RAX</code> and <code>RDX</code>, respectively, then store the result in <code>RAX</code>.</p>
<pre><code class="language-x86asm">addl %rdx, %rax
movl %rax, %rdx
shrl $32, %rdx
addl %rdx, %rax
sarl %rax
</code></pre>
<p>Why this doesn't use a <code>div</code> instruction when dividing? I'm not quite sure. My understanding is that byte manipulation with <code>shrl</code> and <code>sarl</code> is simply faster to execute than <code>div</code>.</p>
<p>Anyways, back to the main goal. We now have a snipped of assembly code that can average the contents of <code>RAX</code> and <code>RDX</code>. To compute the averages of the numbers above, we just need to run it a few times for each set of numbers. Here is the full code:</p>
<pre><code class="language-x86asm">main:
    mov 1, %rax
    mov 7, %rdx

    add %rdx, %rax
    mov %rax, %rdx
    shr $32, %rdx
    add %rdx, %rax
    sar %rax

    mov 2, %rax
    mov 10, %rdx

    add %rdx, %rax
    mov %rax, %rdx
    shr $32, %rdx
    add %rdx, %rax
    sar %rax

    mov 5, %rax
    mov 31, %rdx

    add %rdx, %rax
    mov %rax, %rdx
    shr $32, %rdx
    add %rdx, %rax
    sar %rax
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stack-and-heap"><a class="header" href="#the-stack-and-heap">The Stack and Heap</a></h1>
<p>You may have noticed that things like memory locations, and which registers are used feel rather arbitrary. That's because, up until this point, they have been whatever I feel like using.</p>
<p>In the real world, well-designed conventions exist to ensure everyone's code follows the same set of rules, and uses memory in the same way. This is what lets different pieces of code from different people work together.</p>
<p>The first important piece in the way we manage memory is knowledge of the stack and heap.</p>
<p>Both the stack and heap are separate segments of the same memory in your computer. They start at opposite ends of memory, and grow towards the center. For example, if you had 256 bytes of RAM total, you might find that bytes 0-128 are allocated for the stack, and bytes 128-256 are the heap. It is very possible for these to overlap with eachother, and that is a big problem.</p>
<h2 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h2>
<p>The stack is a First-In-First-Out (FIFO) data structure. Its starting location in memory is constant, and in assembly, the start address can be found in the <code>RBP</code> register.</p>
<p>The stack is modified via <code>push</code> and <code>pop</code> instructions, where <code>push</code> will increase the size of the stack by one byte, then put the specified value in that new spot. <code>pop</code> will give you the top value from the stack, then shrink the stack by one byte.</p>
<p>To see where the &quot;top&quot; of the stack currently sits in memory, you can access the <code>RSP</code> register.</p>
<h2 id="the-heap"><a class="header" href="#the-heap">The Heap</a></h2>
<p>The heap can be thought of as &quot;some memory that exists for when you need it&quot;. How it is managed is different for every programming language and OS. Generally, you as a programmer ask the Operating System to give you some part of the heap to use, then you return it when you are done with it.</p>
<p><em>What</em> you use your portion of heap for is completely up to you, and it can be any size.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brief-introduction-to-functions"><a class="header" href="#brief-introduction-to-functions">Brief Introduction to Functions</a></h1>
<p>In order to understand how a function works, you will need to read the next section, but in order for the next section to make sense, you need to know what a function is.</p>
<p>Functions are essentially snippets of code that can be called from any part of a program. They are an easy way to avoid repetition in your code.</p>
<p>When you call a function in your code, the CPU will jump to the start of that function's machine code, and start executing it. Then, at the end of the function, the CPU will jump back to the point where the function was called from.</p>
<p>Values passed to the function are called <em>parameters</em>, and the value (there can only be one) that the function returns is called the <em>return value</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-conventions"><a class="header" href="#calling-conventions">Calling Conventions</a></h1>
<p>Now that you know what a function is, you may be able to immediately see possible uses for them. One issue you will quickly encounter when trying to use functions is, <em>&quot;How do I pass data to and from a function?&quot;</em>.</p>
<p>The simple answer would be to come up with a little rule for your code. For example, you could say, <em>&quot;Any time I want a function to accept a byte, I can have it read from address &lt;whatever&gt;, and I'll be sure to just put my value there before calling the function&quot;</em>.</p>
<p>And just like that, you invented what is called a <em>Calling Convention</em>! Of course, there will need to be more rules around this system, since you might eventually need to write a function that accepts two bytes, or a function that needs to return a byte.</p>
<p>A new issue may arise when you try calling code written by someone else, since they might have come up with a similar system that is not exactly the same as yours.</p>
<p>Once again, the people who come up with these ideas are pretty smart, and they have come up with a common rule called the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl"><em>cdecl</em></a>, that is used almost everywhere.</p>
<h2 id="the-c-calling-convention"><a class="header" href="#the-c-calling-convention">The C Calling Convention</a></h2>
<p><code>cdecl</code>, or <em>The C Calling Convention</em> is defined as follows. (This section is adapted from <a href="https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf">this document</a>)</p>
<p>This may seem like a lot of work (it is), but it is necessary in order to ensure all functions can inter-operate smoothly.</p>
<h3 id="the-callers-rules"><a class="header" href="#the-callers-rules">The Caller's Rules</a></h3>
<ol>
<li>Before calling a function, the caller should save the contents of <code>RAX</code>, <code>RCX</code>, and <code>RDX</code> by pushing them onto the stack</li>
<li>To pass parameters to a function, the caller should push them onto the stack in reverse order (last argument pushed first)</li>
<li>Call the function</li>
<li>After the function returns, the caller must remove the arguments from the stack</li>
<li>The return value of the function can be found in <code>RAX</code></li>
<li>The caller can then restore the contents of <code>RAX</code>, <code>RCX</code>, and <code>RDX</code> by popping them from the stack</li>
</ol>
<h3 id="the-callees-rules"><a class="header" href="#the-callees-rules">The Callee's Rules</a></h3>
<ol>
<li>The called function should push <code>push</code> the <code>RBP</code> register onto the stack, then copy <code>RSP</code> to <code>RBP</code>
<ul>
<li>This effectively creates a new temporary stack for the function, in reality, this new stack just sits at the top of the real stack</li>
<li>This is achived by executing:</li>
</ul>
</li>
</ol>
<pre><code class="language-x86asm">push %rbp
mov %rsp, %rbp
</code></pre>
<ol start="2">
<li>Make space on the stack if needed</li>
<li>The function must save the contents of <code>RBX</code>, <code>RDI</code>, and <code>RSI</code> by pushing them onto the stack</li>
<li>When finished, place the result of the function in <code>RAX</code></li>
<li>Restore the contents of <code>RBX</code>, <code>RDI</code>, and <code>RSI</code> by popping them from the stack</li>
<li>Pop of any variables made in step 2</li>
<li>Pop the saved <code>RBP</code> value from the stack back in to <code>RBP</code></li>
<li>Execute a <code>ret</code> instruction</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="averaging-two-numbers-now-with-functions"><a class="header" href="#averaging-two-numbers-now-with-functions">Averaging Two Numbers: Now with Functions!</a></h1>
<p>Alright. Let's revisit the <a href="/5.3_averaging.html"><em>Averaging Two numbers</em></a> example from before.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
